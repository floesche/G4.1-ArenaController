<?xml version="1.0" encoding="UTF-8"?>
<model version="5.1.3" links="0">
 <documentation>This is a little more advanced ArenaController example for the Arduino DUE board. The example demonstrates:

1. One active object class &quot;ArenaController&quot; (inside the package &quot;AOs&quot;)
2. A simple state machine
3. The Board Support Package (BSP), see below.

----
# Board configuration:

The external LED needs to be connected between the pins GND and 13, with the short LEG leg at the GND pin.

----
# More info

This example demonstrates the concept of the Board Support Package (BSP), which separates the &quot;What&quot; needs to be done from &quot;How&quot; this is done. The BSP consists of two files &quot;bsp.h&quot; and &quot;bsp.cpp&quot;. The application (active objects) need to include only the &quot;bsp.h&quot; header file and the state machines call only the BSP functions, but don't interact with the hardware directly.

This structure of the code is recommended for applications with only one active object. (See also the dpp_bsp example).</documentation>
 <framework name="qpcpp"/>
 <package name="AOs" stereotype="0x02" namespace="AC::">
  <class name="ArenaController" superclass="qpcpp::QActive">
   <attribute name="command_time_evt_" type="QP::QTimeEvt" visibility="0x00" properties="0x00"/>
   <attribute name="instance" type="ArenaController" visibility="0x00" properties="0x01">
    <documentation>static class instance (Singleton)</documentation>
   </attribute>
   <attribute name="display_frame_time_evt_" type="QP::QTimeEvt" visibility="0x00" properties="0x00"/>
   <operation name="ArenaController" type="" visibility="0x00" properties="0x00">
    <code>: QActive(Q_STATE_CAST(&amp;ArenaController::initial)),
    command_time_evt_(this, COMMAND_TIMEOUT_SIG, 0U),
    display_frame_time_evt_(this, DISPLAY_FRAME_TIMEOUT_SIG, 0U)</code>
   </operation>
   <statechart properties="0x00">
    <initial target="../1/4">
     <action>(void)e; // suppress the compiler warning about unused parameter

//QS_OBJ_DICTIONARY(&amp;ArenaController::instance);

//QS_SIG_DICTIONARY(RESET_SIG, nullptr); // global signals
//QS_SIG_DICTIONARY(ALL_ON_SIG, nullptr);
//QS_SIG_DICTIONARY(ALL_OFF_SIG, nullptr);

//subscribe(RESET_SIG);
subscribe(ALL_ON_SIG);
subscribe(ALL_OFF_SIG);</action>
     <initial_glyph conn="2,17,5,3,5">
      <action box="0,-2,4,2"/>
     </initial_glyph>
    </initial>
    <state name="ArenaOn">
     <entry brief="armCommandPollingTimer(1Hz)">command_time_evt_.armX(BSP::TICKS_PER_SEC/2, BSP::TICKS_PER_SEC/2);</entry>
     <exit brief="disarmCommandPollingTimer()">command_time_evt_.disarm();</exit>
     <tran trig="RESET" target="..">
      <tran_glyph conn="106,9,1,1,5,5,-5">
       <action box="0,-2,7,3"/>
      </tran_glyph>
     </tran>
     <tran trig="COMMAND_TIMEOUT">
      <action>BSP::pollCommand();</action>
      <tran_glyph conn="5,11,3,-1,30">
       <action box="0,0,29,2"/>
      </tran_glyph>
     </tran>
     <tran trig="ALL_OFF" target="../4">
      <tran_glyph conn="5,28,3,2,9,-3">
       <action box="0,0,10,2"/>
      </tran_glyph>
     </tran>
     <state name="DisplayOn">
      <entry brief="armDisplayFrameTimer(50Hz)">display_frame_time_evt_.armX(BSP::TICKS_PER_SEC/100, BSP::TICKS_PER_SEC/100);</entry>
      <exit brief="disarmDisplayFrameTimer()">display_frame_time_evt_.disarm();</exit>
      <state name="AllOn">
       <initial target="../1">
        <initial_glyph conn="66,28,4,0,3">
         <action box="3,0,10,2"/>
        </initial_glyph>
       </initial>
       <state name="AllOnWaiting">
        <entry brief="ledOff()">BSP::ledOff();</entry>
        <tran trig="DISPLAY_FRAME_TIMEOUT" target="../../2">
         <tran_glyph conn="58,33,3,3,-3,9,3">
          <action box="-21,-3,23,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="58,31,14,6">
         <entry box="1,2,9,2"/>
        </state_glyph>
       </state>
       <state name="AllOnDisplaying">
        <entry brief="ledOn()">BSP::ledOn();</entry>
        <tran trig="DISPLAY_FRAME_TIMEOUT" target="../../1">
         <tran_glyph conn="72,42,1,1,2,-9,-2">
          <action box="1,1,21,3"/>
         </tran_glyph>
        </tran>
        <state_glyph node="58,40,14,6">
         <entry box="1,2,10,2"/>
        </state_glyph>
       </state>
       <state_glyph node="36,23,59,26"/>
      </state>
      <state_glyph node="33,15,65,48">
       <entry box="1,2,28,2"/>
       <exit box="1,4,28,2"/>
      </state_glyph>
     </state>
     <state name="DisplayOff">
      <entry brief="ledOff()">BSP::ledOff();</entry>
      <tran trig="ALL_ON" target="../../3/0">
       <tran_glyph conn="26,17,1,3,3,9,7">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="7,15,19,10">
       <entry box="1,2,9,2"/>
      </state_glyph>
     </state>
     <state_glyph node="5,1,101,65">
      <entry box="1,2,63,2"/>
      <exit box="1,4,58,3"/>
     </state_glyph>
    </state>
    <state_diagram size="131,68"/>
   </statechart>
  </class>
  <attribute name="AO_ArenaController" type="QP::QActive * const" visibility="0x00" properties="0x00">
   <code>= &amp;ArenaController::instance;</code>
  </attribute>
 </package>
 <package name="Events" stereotype="0x01" namespace="AC::">
  <class name="CommandEvt" superclass="qpcpp::QEvt"/>
 </package>
 <directory name=".">
  <file name="ArenaController.hpp">
   <text>#ifndef ARENA_CONTROLLER_HPP
#define ARENA_CONTROLLER_HPP

#include &quot;qpcpp.hpp&quot;   // QP-C++ framework
#include &quot;bsp.hpp&quot;

using namespace QP;

namespace AC {

enum ArenaControllerSignals {
    RESET_SIG = QP::Q_USER_SIG,
    ALL_ON_SIG,     // published by BSP to display all panels on
    ALL_OFF_SIG,    // published by BSP to display all panels off
    MAX_PUB_SIG,    // the last published signal
    COMMAND_TIMEOUT_SIG,
    DISPLAY_FRAME_TIMEOUT_SIG,
    MAX_SIG         // the last signal
};

void setup();
void loop();

} // namespace AC

//============================================================================
// generate declarations of all AO classes (state machines)...
$declare${AOs::ArenaController}
//...

$declare${Events}

// genearate declarations of all opaque AO pointers
$declare${AOs::AO_ArenaController}
//...

#endif // ARENA_CONTROLLER_HPP
   </text>
  </file>
  <file name="bsp.hpp">
   <text>
#ifndef BSP_HPP
#define BSP_HPP

class BSP {
public:
    enum { TICKS_PER_SEC = 100} ;
    static void init(void);
    static void pollCommand(void);
    static void ledOff(void);
    static void ledOn(void);
};

#endif // BSP_HPP
   </text>
  </file>
 </directory>
 <directory name="./ArenaController">
  <file name="ArenaController.cpp">
   <text>#include &quot;ArenaController.hpp&quot;  // ArenaController application interface

using namespace QP;

namespace AC {

//............................................................................
void setup() {

    QF::init(); // initialize the framework
    BSP::init(); // initialize the BSP

    // init publish-subscribe
    static QSubscrList subscrSto[AC::MAX_PUB_SIG];
    QF::psInit(subscrSto, Q_DIM(subscrSto));

   // statically allocate event queues for the AOs and start them...
    static QEvt const *arena_controller_queueSto[10];
    AC::AO_ArenaController-&gt;start(1U, // priority
        arena_controller_queueSto, Q_DIM(arena_controller_queueSto),
        (void *)0, 0U); // no stack
    //...
}

//............................................................................
void loop() {
    QF::run(); // run the QF/C++ framework
}

} // namespace AC

//============================================================================
// generate definitions of all AO classes (state machines)...
$define${AOs::ArenaController}
//...

//============================================================================
// generate definitions of all AO opaque pointers...
$define${AOs::AO_ArenaController}
//...
</text>
  </file>
 </directory>
</model>
